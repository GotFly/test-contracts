pragma ever-solidity >= 0.62.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

// import "locklift/src/console.tsol";


// SPDX-License-Identifier: MIT
// pragma ton-solidity >= 0.62.0;

/// Asterizm nonce contract
// contract TestContract {

//     uint static _count;
    
//     event GetHashEvent(uint _value);
//     function getHash(uint64 _chainId, uint _nonce) public {
//         uint result = sha256(abi.encode(_chainId, _nonce).toSlice());

//         emit GetHashEvent(result);
//     }

//     event CheckHashEvent(bool _result, bytes32 _hash, uint _resultHash);
//     function checkHash(uint64 _chainId, uint _nonce, bytes32 _hash) public {
//         uint resultHash = sha256(abi.encode(_chainId, _nonce).toSlice());

//         emit CheckHashEvent(resultHash == uint(_hash), _hash, resultHash);
//     }
// }

// /// Build transfer hash
// /// @param _srcChainId uint64  Chain ID
// /// @param _srcAddress uint  Address
// /// @param _dstChainId uint64  Chain ID
// /// @param _dstAddress uint  Address
// /// @param _txId uint  Transaction ID
// /// @param _payload bytes  Payload
// function _buildTransferHash(uint64 _srcChainId, uint _srcAddress, uint64 _dstChainId, uint _dstAddress, uint _txId, bytes memory _payload) internal pure returns(bytes32) {
//     return sha256(abi.encode(_srcChainId, _srcAddress, _dstChainId, _dstAddress, _txId, _payload));
// }


// 0x0000000000000001000000000000000100000000000000000000000071c7656ec7ab88b098defb751b7401b5f6d8976f00000000000000000000000071c7656ec7ab88b098defb751b7401b5f6d8976f
// 0x68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d732077697468206861736820657374696d6174696f6e

// 0x68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f

// 0x68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f
// 254 - 68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d207769746820686173682065737469
// 6d6174696f6e2c20697420686173206265656e20736f6c7665642f
contract Sample {
    // uint16 static _nonce;

    // uint state;

    // event StateChange(uint _state);

    // constructor(uint _state) public {
    //     tvm.accept();

    //     setState(_state);
    // }

    // function setState(uint _state) public {
    //     tvm.accept();
    //     state = _state;

    //     emit StateChange(_state);
    // }

    // function getDetails()
    //     external
    //     view
    // returns (
    //     uint _state
    // ) {
    //     return state;
    // }

    // constructor() public {
    //     tvm.accept();

    // }
    event GetInputEvent(TvmCell _cell, uint16 _depth);
    event GetHashEvent(uint _hash); // "_value": "te6ccgEBAQEAKgAAUAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
    event GetDecodedEvent(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, bytes _payload);

    // function _buildHash(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, string _str) private pure returns(uint) {
    //     return sha256(abi.encode(_srcChainId, _dstChainId, _srcAddress, _dstAddress, stringHash(_str)).toSlice());
    // }

    function testFunc(bytes _input) external pure {

        // uint length = 1;

        // bytes chunk = _input[from:(to <= length ? to : length)];

        // 1 -       106874969902263813231722716312951672277654786095989753245644957127312510061509
        // 10 -      58659839442358205848808369853057773145955734381062902539393874402431425178643
        // asd1 -    102987336249554097029535212322581322789799900648198034993379397001115665086549
        // "" -      102987336249554097029535212322581322789799900648198034993379397001115665086549

        // '0xea'-   102987336249554097029535212322581322789799900648198034993379397001115665086549
        // '0x00' -  02987336249554097029535212322581322789799900648198034993379397001115665086549
        //           102987336249554097029535212322581322789799900648198034993379397001115665086549
        TvmCell a = abi.encode(_input);
        // uint result = sha256(a.toSlice());

        // bytes test = hex"ae";

        // TvmSlice test = abi.encode(hex"ae").toSlice();

        TvmSlice test = a.toSlice();

        uint result = sha256(test.loadRefAsSlice());

        // (bytes b) = abi.decode(a, (bytes));


        // '0x49206861766520313030e282ac' - 98073077605334539053897186023409572827616073650876292130247530935523928574705
        // '0x00'                         - 52965160108446166288309480364938175698690249970306104862564155754591719015250

        // uint result = tvm.hash(abi.encode(_input).toSlice());


        //  ''   -  102987336249554097029535212322581322789799900648198034993379397001115665086549
        // '0xea'-  110105890185646802116874256035879291130903789336395184891418265810108588972985
        // '0x00' - 106780894380051850927074825988337669854374078474582217167387333393077172365313

        // uint result = sha256(_input);

        // uint result = tvm.hash(_input);

        // TvmCell result =  abi.encode(input);
        // TvmCell result =  abi.encode(input);


        // (uint length, uint a, uint b) = result.dataSize();
        // emit GetInputEvent(a);
        // emit GetDecodedEvent(b);
        emit GetHashEvent(result);
        tvm.accept();

        // console.log(format("Result = {}", result));
    }

    // 0x71C7656EC7ab88b098defB751B7401B5f6d8976F
    // 4d6f6c65737469652072697375732064696374756d73742e2049642073617069656e206d6f6c6c6973206e6f6e2061656e65616e206573742e20436f6e7365637465747572206d6f6c6573746965207365642061656e65616e20686162697461737365206d6f726269206e6563206c656f2c206d6f726269206d6f6c657374696520726973757320697073756d20616d65742c20616d6574206d6f726269206d6f6c6573746965206964206a7573746f2073697420726973757320736564206e6f6e20616363756d73616e207669746165206f726e617265206573742e204d6f726269206e6f6e206c7563747573206461706962757320736974206d616c657375616461206f7263692c206d617474697320616d65742c206461706962757320736974206d6174746973206e6f6e206c65637475732064696374756d2e20446f6c6f722076656c69742065742e204d6f6c6573746965206f7263692c2076656c69742064617069627573206e756c6c6120696e74657264756d206c656f2c20726973757320696e2076756c70757461746520696e74657264756d2075726e6120656c656966656e642070656c6c656e7465737175652076656c697420696e20746f72746f722c20706c617465612064696374756d20656c69742e20546f72746f722c2073697420656c656966656e6420636f6e73

    event GetTestEvent(bytes _b);
    event GetLengthEvent(uint _l);


// 68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f68656c6c6f2066726f6d20746f6e2d736f6c696469747920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f68656c6c6f2066726f6d20746f6e2d736f6c696469747
// 920616e642070726f626c656d2077697468206861736820657374696d6174696f6e2c20697420686173206265656e20736f6c7665642f

    function bytesHash(bytes _data) internal pure returns(uint) {
        uint length = _data.length;
        uint8 chunkLength = 127;
        uint hash;
        for (uint i = 0; i < math.divc(length, chunkLength); i++) {
            uint from = chunkLength * i;
            uint to = from + chunkLength;
            bytes chunk = _data[from:(to <= length ? to : length)];
            hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
        }

        return hash;
    }

    function _buildHash(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, bytes _payload) private returns(uint) {

        TvmCell staticCell = abi.encode(_srcChainId, _dstChainId, _srcAddress, _dstAddress);

        TvmSlice staticSlice = staticCell.toSlice();
        uint hash = sha256(staticSlice);

        uint length = _payload.length;
        uint chunkLength = 127;

        if (length > chunkLength) {
            for (uint i = 0; i < math.divc(length, chunkLength); i++) {
                uint from = chunkLength * i;
                uint to = from + chunkLength;
                bytes chunk = _payload[from:(to <= length ? to : length)];
                hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
            }



            // hash = sha256(abi.encode(hash, bytesHash(bytes(_payload))).toSlice());
            // for (uint i = 0; i < math.divc(length, chunkLength); i++) {
                // steps += 1;
                // uint from = chunkLength * i;
                // uint to = from + chunkLength <= length ? from + chunkLength : length;
                // uint to = from + chunkLength;
                // bytes chunk = _payload[from:(to <= length ? to : length)];
                // bytes chunk;
                // for(uint j = 0; j < 10; j++){
                //     // chunk.append(bytes(_payload[j]));
                // }
            // }
        //         // bytes chunk = _payload[from:to];

        // // //         // bytes chunk = _payload[from:to];
        // // //         // TvmSlice chunkCell = abi.encode(chunk).toSlice();
        // // //         // TvmSlice refSlice = chunkCell.loadRefAsSlice();
        // // //         // hash = sha256(abi.encode(hash, sha256(refSlice)).toSlice());
        // // //         bytes chunk = new bytes(to - from);
            // }

            // TvmSlice payload = _payload.toSlice();
            // // hash = sha256(abi.encode(hash, sha256(payload)).toSlice());
            // uint i = payload.depth();
            // emit GetLengthEvent(i);
            // while (i != 0) {
            //     // TvmSlice refSlice = payload.loadRefAsSlice();
            //     // i = refSlice.depth();
            //     // if (i != 0) {
            //     //     payload = payload.loadRefAsSlice();
            //     // }
            //     // hash = sha256(abi.encode(hash, sha256(refSlice)).toSlice());
            // }
        } else {
            TvmSlice dynamicCell = abi.encode(_payload).toSlice();
            TvmSlice dynamicSlice = dynamicCell.loadRefAsSlice();
            hash = sha256(abi.encode(hash, sha256(dynamicSlice)).toSlice());
        }

        return hash;
    }


    // function _buildHashTest(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, bytes _payload) private pure returns(uint) {
        
    //     TvmCell cell = abi.encode(_srcChainId, _dstChainId, _srcAddress, _dstAddress, _payload);

    //     (uint64 srcChainId, uint64 dstChainId, uint srcAddress, uint dstAddress, bytes payload) = abi.decode(cell, (uint64, uint64, uint, uint, bytes));

    //     uint16 cellDepth = cell.depth();

    //     emit GetInputEvent(cell, cellDepth);
    //     emit GetDecodedEvent(srcChainId, dstChainId, srcAddress, dstAddress, payload);

    //     uint i = cellDepth;

    //     TvmSlice tmpSlice = cell.toSlice();

    //     uint hash = sha256(tmpSlice);

    //     while (i != 0) {

    //         TvmSlice refSlice = tmpSlice.loadRefAsSlice();

    //         i = refSlice.depth();

    //         if (i != 0) {
    //             tmpSlice = tmpSlice.loadRefAsSlice();
    //         }

    //         hash = sha256(abi.encode(hash, sha256(refSlice)).toSlice());
    //     }
    //     return hash;
    // }
    
    function getHash(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, bytes _payload) public {
        tvm.accept();
        uint resultHash = _buildHash(_srcChainId, _dstChainId, _srcAddress, _dstAddress, _payload);

        emit GetHashEvent(resultHash);
    }

}
