pragma ton-solidity >= 0.70.0;

/// Asterizm nonce contract
contract TestContract {

    // uint static count_;

    event GetPayloadEvent(string _mark, bytes _data);
    event GetDepthtEvent(string _mark, uint16 _d);
    event GetStepEvent(uint _i, bytes _chunk, uint _hash);

    event GetLoopEvent(string _mark, uint _i, uint16 _bits, bytes _data);

    event GetHashEvent(uint _hash);
    function getHash(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, uint _txId, uint _dstAddressUint, uint _amount, uint8 _decimals, bytes _param1) public pure {
        tvm.accept();
        TvmCell payload = abi.encode(_dstAddressUint, _amount, _txId, _decimals, _param1);
        TvmCell packedData = abi.encode(_srcChainId, _dstChainId, _srcAddress, _dstAddress, _txId, bytes(payload.toSlice()));
        emit GetHashEvent(_buildHash3(packedData));
    }

    event CheckHashEvent(bool _result, bytes32 _hash, uint _resultHash);
    function checkHash(uint64 _srcChainId, uint64 _dstChainId, uint _srcAddress, uint _dstAddress, uint _txId, uint _dstAddressUint, uint _amount, uint8 _decimals, bytes _param1, bytes32 _hash) public pure {
        tvm.accept();
        TvmCell payload = abi.encode(_dstAddressUint, _amount, _txId, _decimals, _param1);
        TvmCell packedData = abi.encode(_srcChainId, _dstChainId, _srcAddress, _dstAddress, _txId, bytes(payload.toSlice()));
        uint resultHash = _buildHash3(packedData);

        emit CheckHashEvent(resultHash == uint(_hash), _hash, resultHash);
    }
    
    /// var 1
    function _buildHash1(TvmCell encodedCell) private pure returns(uint) {
        TvmSlice encodedSlice = encodedCell.toSlice();
        uint hash = sha256(encodedSlice);
        TvmSlice payloadSlice = encodedSlice.loadRefAsSlice();
        uint16 payloadDepth = payloadSlice.depth();

        bytes chunk = "";
        for (uint i = 0; i <= payloadDepth; i++) {   
            uint8 r = payloadSlice.refs();
            uint16 b = payloadSlice.bits();

            // Main tree
            if (b > 0) {
                // var 1
                bytes p = bytes(payloadSlice);
                for (uint j = 0; j < b / 8; j++) {
                    if (chunk.length + 1 <= 127) {
                        chunk.append(bytes(p[j]));
                    } 
                    if (chunk.length == 127) {
                        hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
                        emit GetStepEvent(i, chunk, sha256(chunk));
                        chunk = "";
                    }
                }

                if (chunk.length > 0 && chunk.length < 127 && i == payloadDepth) {
                    hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
                    emit GetStepEvent(i, chunk, sha256(chunk));
                }
            }
            
            if (r > 0) {
                payloadSlice = payloadSlice.loadRefAsSlice();
            }
        }

        return hash;
    }

    /// var 2
    function _buildHash2(TvmCell encodedCell) private pure returns(uint) {
        TvmSlice encodedSlice = encodedCell.toSlice();
        uint hash = sha256(encodedSlice);
        TvmSlice payloadSlice = encodedSlice.loadRefAsSlice();
        uint16 payloadDepth = payloadSlice.depth();

        bytes chunk = "";
        uint padding = 0;
        for (uint i = 0; i <= payloadDepth; i++) {   
            uint8 r = payloadSlice.refs();
            uint16 b = payloadSlice.bits();

            // Main tree
            if (b > 0) {
                bytes p = bytes(payloadSlice);

                // var 2
                if (chunk.length == 0 && padding == 0) {
                    chunk = p[0:b / 8];
                    padding = chunk.length - 1;
                } else if (chunk.length > 0 && chunk.length < 127) {
                    if (padding != 0  && b / 8 >= padding) {
                        chunk.append(p[0:padding]);
                    }
                    if (padding != 0  && b / 8 < padding) {
                        chunk.append(p[0:b / 8]);
                    } 
                }

                // emit GetLoopEvent("Loop", i, b, p, padding, chunk, chunk.length);

                if (chunk.length == 127) {
                    hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
                    emit GetStepEvent(i, chunk, sha256(chunk));
                    chunk = "";
                    chunk.append(p[padding:b / 8]);
                    padding = chunk.length - 1;
                }

                if (chunk.length > 0 && chunk.length < 127 && i == payloadDepth) {
                    hash = sha256(abi.encode(hash, sha256(chunk)).toSlice());
                    emit GetStepEvent(i, chunk, sha256(chunk));
                }
            }
            
            if (r > 0) {
                payloadSlice = payloadSlice.loadRefAsSlice();
            }
        }

        return hash;
    }

    /// var 3
    function _buildHash3(TvmCell encodedCell) private pure returns(uint) {
        TvmSlice encodedSlice = encodedCell.toSlice();
        uint hash = sha256(encodedSlice);
        TvmSlice payloadSlice = encodedSlice.loadRefAsSlice();
        uint16 payloadDepth = payloadSlice.depth();

        bytes chunk = "";
        for (uint i = 0; i <= payloadDepth; i++) {   
            uint8 r = payloadSlice.refs();
            uint16 b = payloadSlice.bits();
            // Main tree
            if (b > 0) {
                chunk.append(bytes(payloadSlice)[0:b / 8]);
            }
            if (r > 0) {
                payloadSlice = payloadSlice.loadRefAsSlice();
            }
        }

        TvmSlice chunkSlice = TvmSlice(chunk);
        uint16 chunkDepth = chunkSlice.depth();
    
        emit GetDepthtEvent("Slice", chunkDepth);

        for (uint i = 0; i <= chunkDepth; i++) {   
            uint8 r = chunkSlice.refs();
            uint16 b = chunkSlice.bits();
            emit GetLoopEvent("Loop", i, b, bytes(chunkSlice));
            if (b > 0) {
                hash = sha256(abi.encode(hash, sha256(chunkSlice)).toSlice());
                emit GetStepEvent(i, bytes(chunkSlice), sha256(chunkSlice));
            }
            if (r > 0) {
                chunkSlice = chunkSlice.loadRefAsSlice();
            }
        }

        return hash;
    }
}
